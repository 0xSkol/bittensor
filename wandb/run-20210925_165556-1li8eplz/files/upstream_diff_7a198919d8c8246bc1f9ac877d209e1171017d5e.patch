diff --git a/Untitled1.ipynb b/Untitled1.ipynb
new file mode 100644
index 0000000..4c3cbb0
--- /dev/null
+++ b/Untitled1.ipynb
@@ -0,0 +1,306 @@
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "id": "6cc0ca1a-5235-4763-8259-2b042f3cb19a",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "\n",
+    "# The MIT License (MIT)\n",
+    "# Copyright © 2021 Yuma Rao\n",
+    "\n",
+    "# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated \n",
+    "# documentation files (the “Software”), to deal in the Software without restriction, including without limitation \n",
+    "# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, \n",
+    "# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n",
+    "\n",
+    "# The above copyright notice and this permission notice shall be included in all copies or substantial portions of \n",
+    "# the Software.\n",
+    "\n",
+    "# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n",
+    "# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL \n",
+    "# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION \n",
+    "# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n",
+    "# DEALINGS IN THE SOFTWARE.\n",
+    "\n",
+    "import os\n",
+    "import stat\n",
+    "import json\n",
+    "import bittensor\n",
+    "import getpass\n",
+    "import random\n",
+    "import string\n",
+    "from password_strength import PasswordPolicy\n",
+    "from ansible_vault import Vault\n",
+    "from substrateinterface import Keypair\n",
+    "from termcolor import colored\n",
+    "\n",
+    "def may_write_to_path( full_path:str, overwrite, force_through_user_input) -> bool:\n",
+    "    if not os.path.exists( full_path ):\n",
+    "        os.makedirs( os.path.dirname (full_path) )\n",
+    "    if not os.access( full_path, os.W_OK ):\n",
+    "        print ('1')\n",
+    "        return False\n",
+    "    if not os.access( os.path.dirname (full_path), os.W_OK ) :\n",
+    "        print ('2')\n",
+    "        return False\n",
+    "    if os.path.isfile(full_path):\n",
+    "        if overwrite or force_through_user_input:\n",
+    "            return True\n",
+    "        print ('3')\n",
+    "        choice = input(\"File {} already exists. Overwrite ? (y/N) \".format(full_path))\n",
+    "        if choice == \"y\":\n",
+    "            return True\n",
+    "        else:\n",
+    "            print ('ss')\n",
+    "            return False\n",
+    "    else:\n",
+    "        return True\n",
+    "\n",
+    "def set_file_permissions(path):\n",
+    "    os.chmod(path, stat.S_IRUSR | stat.S_IWUSR)\n",
+    "    pass\n",
+    "\n",
+    "def validate_password(password):\n",
+    "    policy = PasswordPolicy.from_names(\n",
+    "        strength=0.20,\n",
+    "        entropybits=10,\n",
+    "        length=6,\n",
+    "    )\n",
+    "    if not password:\n",
+    "        return False\n",
+    "\n",
+    "    tested_pass = policy.password( password )\n",
+    "    result = tested_pass.test()\n",
+    "    if len(result) > 0:\n",
+    "        print(colored('Password not strong enough. Try increasing the length of the password or the password complexity'))\n",
+    "        return False\n",
+    "\n",
+    "    password_verification = getpass.getpass(\"Retype your password: \")\n",
+    "    if password != password_verification:\n",
+    "        print(\"Passwords do not match\")\n",
+    "        return False\n",
+    "\n",
+    "    return True\n",
+    "\n",
+    "def input_password( force_through_user_input ):\n",
+    "    valid = False\n",
+    "    if force_through_user_input:\n",
+    "        generated_password = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(10))\n",
+    "        print(colored('***WARNING***: you are encrypting this keypair with the follwoing randomly generate password: {}'.format(generated_password), 'red'))\n",
+    "        return generated_password\n",
+    "    while not valid:\n",
+    "        password = getpass.getpass(\"Specify password for key encryption: \")\n",
+    "        valid = validate_password(password)\n",
+    "    return password\n",
+    "\n",
+    "def write_pubkey_to_text_file( full_path, keypair:Keypair, overwrite ):\n",
+    "    pub_fullpath = os.path.expanduser( full_path ) + \"pub.txt\",\n",
+    "    if not may_write_to_path( pub_fullpath, overwrite ):\n",
+    "        print(colored(\"No write access for {}\" % pub_fullpath, 'red'))\n",
+    "    with open(pub_fullpath, \"w\") as pubfile:\n",
+    "        pubfile.write( keypair.public_key.strip() )\n",
+    "\n",
+    "def keypair_to_dict( keypair: Keypair ):\n",
+    "    return {\n",
+    "        'accountId': keypair.public_key,\n",
+    "        'publicKey': keypair.public_key,\n",
+    "        'secretPhrase': keypair.mnemonic,\n",
+    "        'secretSeed': \"0x\" + keypair.seed_hex,\n",
+    "        'ss58Address': keypair.ss58_address\n",
+    "    }\n",
+    "\n",
+    "def generate_new_keypair( words: int ):\n",
+    "    mnemonic = Keypair.generate_mnemonic( words )\n",
+    "    keypair = Keypair.create_from_mnemonic( mnemonic )\n",
+    "    return keypair\n",
+    "\n",
+    "def display_mnemonic_msg( kepair : Keypair ):\n",
+    "    mnemonic = kepair.mnemonic\n",
+    "    mnemonic_green = colored(mnemonic, 'green')\n",
+    "    print (colored(\"\\nIMPORTANT: Store this mnemonic in a secure (preferable offline place), as anyone \" \\\n",
+    "                \"who has possesion of this mnemonic can use it to regenerate the key and access your tokens. \\n\", \"red\"))\n",
+    "    print (\"The mnemonic to the new key is:\\n\\n{}\\n\".format(mnemonic_green))\n",
+    "    print (\"You can use the mnemonic to recreate the key in case it gets lost. The command to use to regenerate the key using this mnemonic is:\")\n",
+    "    print(\"bittensor regen --mnemonic {}\".format(mnemonic))\n",
+    "    print('')\n",
+    "\n",
+    "def confirm_no_password( force_through_user_input ):\n",
+    "    print(colored('*** WARNING ***', 'white'))\n",
+    "    print(colored('You have specified not using a password.', 'white'))\n",
+    "    print(colored('This means that the generated key will be stored as plaintext in the keyfile', 'white'))\n",
+    "    print(colored('The benefit of this is that you will not be prompted for a password when bittensor starts', 'white'))\n",
+    "    print(colored('The drawback is that an attacker has access to the key if they have access to the account bittensor runs on', 'white'))\n",
+    "    print()\n",
+    "    if force_through_user_input:\n",
+    "        return True\n",
+    "    choice = input(\"Do you wish to proceed? (Y/n) \")\n",
+    "    if choice in [\"n\", \"N\"]:\n",
+    "        return False\n",
+    "\n",
+    "    return True\n",
+    "\n",
+    "def create_new_encrypted_keypair ( \n",
+    "        path: str,\n",
+    "        name: str,\n",
+    "        n_words: int, \n",
+    "        use_password: bool, \n",
+    "        overwrite:bool,\n",
+    "        is_coldkey:bool,\n",
+    "        force_through_user_input:bool,\n",
+    "    ) -> 'bittensor.Wallet':  \n",
+    "    r\"\"\" Creates a new (possibly encrypted) keypair at the specified path with name.\n",
+    "            Args:\n",
+    "                path (`type`:str)\n",
+    "                    The file path we are saving the keypair under.\n",
+    "                name (`type`:str)\n",
+    "                    The name file we are saving the keypair to.\n",
+    "                n_words (`type`:int):\n",
+    "                    The number of mnemonic words to use.\n",
+    "                use_password (`type`:bool):\n",
+    "                    If True, the keypair will be encrypted and passowrd protected.\n",
+    "                overwrite (`type`:bool):\n",
+    "                    If True, the keypair will overwrite the file already saved \n",
+    "                    under this path (if it exists.)\n",
+    "                is_coldkey (`type`:bool):\n",
+    "                    If True, the keypair is treated as the coldkey and the .ss58.pub and .ed255.pub are created\n",
+    "                force_through_user_input (`type`:bool):\n",
+    "                    If True, the file function forces all operations by passing 'yes'\n",
+    "\n",
+    "    \"\"\"\n",
+    "    # Check write permissions.\n",
+    "    full_path = os.path.expanduser(os.path.join(path, name))\n",
+    "    if not may_write_to_path( full_path, overwrite, force_through_user_input ):\n",
+    "        print ('here')\n",
+    "        print(colored(\"No write access for {}\".format(full_path), 'red'))\n",
+    "        return False\n",
+    "\n",
+    "    # Create Key.\n",
+    "    keypair = generate_new_keypair( n_words )\n",
+    "    display_mnemonic_msg( keypair )\n",
+    "\n",
+    "    # Optionally Encrypt\n",
+    "    keypair_data = json.dumps( keypair_to_dict( keypair ) ).encode()\n",
+    "    if use_password:\n",
+    "        keypair_data = json.dumps( keypair_to_dict( keypair ) ).encode()\n",
+    "        vault = Vault( input_password( force_through_user_input ) )\n",
+    "        vault.dump( keypair_data, open( full_path, 'w') )\n",
+    "    else:\n",
+    "        if is_coldkey:\n",
+    "            confirm_no_password( force_through_user_input )\n",
+    "\n",
+    "    # Optionally write pubkey ed255 to file.\n",
+    "    if is_coldkey:\n",
+    "        write_pubkey_to_text_file( full_path, keypair, overwrite )\n",
+    "\n",
+    "    # Set permissions.\n",
+    "    set_file_permissions( full_path )"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "id": "1fa2ed23-f7d1-4fec-88ec-831cdfa36683",
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "\u001b[31m\n",
+      "IMPORTANT: Store this mnemonic in a secure (preferable offline place), as anyone who has possesion of this mnemonic can use it to regenerate the key and access your tokens. \n",
+      "\u001b[0m\n",
+      "The mnemonic to the new key is:\n",
+      "\n",
+      "\u001b[32mfaith evolve wedding fork clog gas latin front battle great amused guide\u001b[0m\n",
+      "\n",
+      "You can use the mnemonic to recreate the key in case it gets lost. The command to use to regenerate the key using this mnemonic is:\n",
+      "bittensor regen --mnemonic faith evolve wedding fork clog gas latin front battle great amused guide\n",
+      "\n"
+     ]
+    },
+    {
+     "name": "stdin",
+     "output_type": "stream",
+     "text": [
+      "Specify password for key encryption:  ··············\n",
+      "Retype your password:  ·············\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "Passwords do not match\n"
+     ]
+    },
+    {
+     "name": "stdin",
+     "output_type": "stream",
+     "text": [
+      "Specify password for key encryption:  ··············\n",
+      "Retype your password:  ··············\n"
+     ]
+    },
+    {
+     "ename": "IsADirectoryError",
+     "evalue": "[Errno 21] Is a directory: '/Users/const/.test_bittensor/wallets/test_wallet1'",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mIsADirectoryError\u001b[0m                         Traceback (most recent call last)",
+      "\u001b[0;32m<ipython-input-2-a3d1e0e883ae>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m create_new_encrypted_keypair(\n\u001b[0m\u001b[1;32m      2\u001b[0m     \u001b[0mpath\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'~/.test_bittensor/wallets'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m     \u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'test_wallet1'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0mn_words\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m12\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0muse_password\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
+      "\u001b[0;32m<ipython-input-1-67a574c0e7b7>\u001b[0m in \u001b[0;36mcreate_new_encrypted_keypair\u001b[0;34m(path, name, n_words, use_password, overwrite, is_coldkey, force_through_user_input)\u001b[0m\n\u001b[1;32m    177\u001b[0m         \u001b[0mkeypair_data\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mjson\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdumps\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mkeypair_to_dict\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mkeypair\u001b[0m \u001b[0;34m)\u001b[0m \u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mencode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    178\u001b[0m         \u001b[0mvault\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mVault\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0minput_password\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mforce_through_user_input\u001b[0m \u001b[0;34m)\u001b[0m \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 179\u001b[0;31m         \u001b[0mvault\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mkeypair_data\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m \u001b[0mfull_path\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m'w'\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    180\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    181\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mis_coldkey\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
+      "\u001b[0;31mIsADirectoryError\u001b[0m: [Errno 21] Is a directory: '/Users/const/.test_bittensor/wallets/test_wallet1'"
+     ]
+    }
+   ],
+   "source": [
+    "\n",
+    "\n",
+    "\n",
+    "create_new_encrypted_keypair(\n",
+    "    path = '~/.test_bittensor/wallets',\n",
+    "    name = 'test_wallet1',\n",
+    "    n_words = 12, \n",
+    "    use_password = True, \n",
+    "    overwrite = False,\n",
+    "    is_coldkey = True,\n",
+    "    force_through_user_input = False\n",
+    ")\n",
+    "\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "04f7ef33-34e6-483f-b5aa-2d78e0c4b50a",
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "Python 3 (ipykernel)",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.8.11"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/bittensor/__init__.py b/bittensor/__init__.py
index 2436ae0..9e8d1f3 100644
--- a/bittensor/__init__.py
+++ b/bittensor/__init__.py
@@ -21,7 +21,7 @@ from typing import Callable
 
 # Bittensor code and protocol version.
 __version__ = '1.5.0'
-__version_as_int__ = (100 * 1) + (10 * 4) + (1 * 0)  # Integer representation
+__version_as_int__ = (100 * 1) + (10 * 5) + (1 * 0)  # Integer representation
 
 # Vocabulary dimension.
 #__vocab_size__ = len( tokenizer ) + len( tokenizer.additional_special_tokens) + 100 # Plus 100 for eventual token size increase.
diff --git a/miners/text/template_miner.py b/miners/text/template_miner.py
index 4518dad..a70b1af 100644
--- a/miners/text/template_miner.py
+++ b/miners/text/template_miner.py
@@ -503,10 +503,9 @@ class Miner:
             )
             return output.local_hidden
 
-        uid =self.neuron.metagraph.hotkeys.index(pubkey)
-        priority = self.neuron.metagraph.S[uid]
-        future = self.thread_pool.submit(call,inputs=inputs_x,priority=priority)
-        return future.result(timeout= self.config.miner.timeout)
+        priority = self.neuron.metagraph.S[ self.neuron.metagraph.hotkeys.index(pubkey) ] / sys.getsizeof(inputs_x)
+        future = self.thread_pool.submit( call,inputs = inputs_x, priority = priority )
+        return future.result(timeout = self.config.miner.timeout)
 
     # ---- Axon Backward call ----
     def backward_text ( self, pubkey:str, inputs_x:torch.FloatTensor, grads_dy:torch.FloatTensor ) -> torch.FloatTensor:
@@ -541,13 +540,8 @@ class Miner:
                     )
                     return inputs_x.grad if inputs_x.grad != None else None                    
 
-            uid =self.neuron.metagraph.hotkeys.index(pubkey)
-            priority = self.neuron.metagraph.S[uid]
-            future = self.thread_pool.submit(call, input=inputs_x.to( self.device ), grad=grads_dy.to( self.device ), priority=priority)
-            return future.result(timeout= self.config.miner.timeout)            
-        # if ! compute_remote_gradients, NO-OP.
-        else:
-            return None
+            priority = self.neuron.metagraph.S[ self.neuron.metagraph.hotkeys.index(pubkey) ] / sys.getsizeof(inputs_x)
+            self.thread_pool.submit(call, input=inputs_x.to( self.device ), grad=grads_dy.to( self.device ), priority=priority)
 
     def checkpoint( self ):
         r""" Optionally Saves, updates and then reloads the miner training state.
diff --git a/miners/text/template_server.py b/miners/text/template_server.py
index b0a32e3..0704d6d 100644
--- a/miners/text/template_server.py
+++ b/miners/text/template_server.py
@@ -23,23 +23,25 @@ Example:
 """
 import argparse
 import bittensor
+import sys
 import torch
 import time
 import wandb
 import datetime
-from qqdm import qqdm
 from transformers import BertModel, BertConfig
 
 def config ():
     parser = argparse.ArgumentParser()
     parser.add_argument('--miner.learning_rate', type=float, help='Training initial learning rate.', default=1)
     parser.add_argument('--miner.momentum', type=float, help='optimizer momentum.', default=0.8)
+    parser.add_argument('--miner.timeout', type=int, help='Number of seconds to wait for axon request', default=2)
     parser.add_argument('--miner.clip_gradients', type=float, help='Implement gradient clipping to avoid exploding loss on smaller architectures.', default=1.0)
     parser.add_argument('--miner.device', type=str, help='miner default training device cpu/cuda', default=("cuda" if torch.cuda.is_available() else "cpu"))
     bittensor.wallet.add_args( parser )
     bittensor.axon.add_args( parser )
     bittensor.subtensor.add_args( parser )
     bittensor.logging.add_args( parser )
+    bittensor.prioritythreadpool.add_args( parser )
     return bittensor.config( parser )
 
 def main( config ):
@@ -87,20 +89,35 @@ def main( config ):
         momentum = config.miner.momentum,
     )
 
+    # Priority thread pool 
+    thread_pool = bittensor.prioritythreadpool(
+        config = config
+    )
+
     # Define our forward function.
     def forward_text ( pubkey, inputs_x, modality ):
-        return model( inputs_x.to(device) ).last_hidden_state
+        def run_call( inputs_x ):
+            return model( inputs_x ).last_hidden_state
+        # Make call based on stake priority.
+        priority = metagraph.S[ metagraph.hotkeys.index(pubkey) ] / sys.getsizeof(inputs_x)
+        future = thread_pool.submit( run_call, inputs_x = inputs_x.to( device ), priority = priority )
+        return future.result(timeout = config.miner.timeout )
+
 
     # Define our backward function.
     def backward_text ( pubkey:str, inputs_x, grads_dy, modality ):
-        with torch.enable_grad():
-            outputs_y = model( inputs_x.to(device) ).last_hidden_state
-            torch.autograd.backward (
-                tensors = [ outputs_y.to(device) ],
-                grad_tensors = [ grads_dy.to(device) ]
-            )
-            optimizer.step() # Applies accumulated gradients.
-            optimizer.zero_grad() 
+        def run_call( inputs_x, grads_dy ):
+            with torch.enable_grad():
+                outputs_y = model( inputs_x ).last_hidden_state
+                torch.autograd.backward (
+                    tensors = [ outputs_y ],
+                    grad_tensors = [ grads_dy ]
+                )
+                optimizer.step() # Applies accumulated gradients.
+                optimizer.zero_grad() 
+        # Make call based on stake priority.
+        priority = metagraph.S[ metagraph.hotkeys.index(pubkey) ] / sys.getsizeof(inputs_x)
+        thread_pool.submit( run_call, input=inputs_x.to( device ), grad=grads_dy.to( device ), priority = priority )
 
     # Create our axon server and subscribe it to the network.
     axon = bittensor.axon (
